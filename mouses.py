"""Пол прямоугольной формы выложен плитками 1х1,
на каждую из которых высыпано от 0 до K зернышек (K <= 30000).
Размеры пола MxN.
Мышка выбегает из верхнего левого угла и двигается к входу в противоложном углу.
Мышка может двигаться только вправо или вниз, собирая все зернышки с плитки,
на ктр она находится.
Входные данные:
Дана матрица MxN (M,N <= 100). Матрица содержит кол-во зернышек в каждой плитке.
Вывести кол-во зернышек на каждом шаге маршрута мышки, при ктр она соберет наибольшее
кол-во зернышек."""

import numpy as np


def mouse(matrix):
    a = np.empty(matrix.shape) # максимальное количество зернышек которые можем собрать дойдя
    #  до той клеточки
    b = np.empty(matrix.shape) #направления
    m, n = matrix.shape
    for i in range(m):
        for j in range(n):
            a[i, j], b[i, j] = get_max(i, j, matrix, a)
    way = []
    i = m - 1
    j = n - 1
    way.append(matrix[i, j])# а теперь возвращаемся по направлениях
    while b[i, j] != 0:
        if b[i, j] == -1:
            i -= 1
        elif b[i, j] == 1:
            j -= 1
        way.append(matrix[i, j])
    return way[::-1]


def get_max(i, j, matrix, a):
    if i == 0 and j == 0: #угловому элементу передаем количество зернышек на нем и соответственно
        #нулевое направление
        return matrix[i, j], 0
    if i == 0:
        return a[0, j - 1] + matrix[i, j], 1 #если двигаемся по строчке верхней - то
        #только  вправо и добраться мы до них можем одним способом
    if j == 0:
        return a[i - 1, 0] + matrix[i, j], -1 #аналогично по столбцу первому
    else:
        flag = -1 if a[i - 1, j] > a[i, j - 1] else 1 #если больше зернышек
        #  собрали на левом элементе - будем идти ко следующему оттуда,
        #  соответственно наоборот
        return max(a[i - 1, j], a[i, j - 1]) + matrix[i, j], flag


if __name__ == "__main__":
    print(mouse(np.matrix('3 2 4; 3 2 4; 1 5 1')))
    print(mouse(np.matrix('1 5 1 1; 1 1 1 1; 5 5 1 1')))
    print(mouse(np.matrix('4 5 6 7; 4 5 6 7; 1 2 2 3; 1 4 5 6')))