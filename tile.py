"""
Коридор NxM метров нужно застелить N плитками 1xM метров, чтобы не было не застеленной поверхности.

Нужно написать функцию, ктр найдет кол-во способов это сделать.

Например, для коридора 6x4 метра существует 4-е способа застелить плитками 1x4
"""
from functools import reduce

def tile(n, m):
    d = n // m
    res = 1 #все плитки лежат горизонтально
    for i in range(1, d+1): #і - количество вертикальных
        # блоков mxm в нашей расстановке
        rest = n - m * i # количество горизонтальных плиток при таком раскладе
        #максимальное количество частей, на которые можем разбить
        #горизонтальные плитки - і + 1
        #способы положить плитку - способы разложить rest плиток на разное
        # количество частей разного размера
        #(например, есть два блока mxm и 5 плиток. Мы можем разбить эти  5 плиток
        #на три части (1,1,3) (3,1,1) и т.д итого 4!/(2!2!) = 6 способов,
        # можем на две части, можем всего на одну.
        #Итого rest плиток на k частей мы можем разложить (rest-1)!/((k-1)!(rest-k)!)
        #способами. Сумма по k от 2 до i+1 будет количеством способов
        #разбить наши вертикальные блоки горизонтальными, остается добавить
        #  i + 1 - количество способов разложить плитки, когда все rest плиток - один блок
        # Если же горизонтальных плиток нету при таком количестве вертикальных блоков -
        #просто добавляем еще один вариант - все вертикальные, если у нас 1 плитка,
        # - добавляем i + 1 способ
        if rest > 1:
            blocks = sum(factorial(rest - 1)/(factorial(k - 1)*factorial(rest - k)) for k in range(2, i+2))
            res += blocks + i + 1
        elif rest == 1:
            res += i + 1
        else:
            res += 1
    return res

def factorial(n):
  return reduce(lambda x, y: x * y, range(1, n + 1)) if n > 1 else 1

if __name__ == '__main__':
    print(tile(6, 4))
    print(tile(8, 4))
    print(tile(2, 2))
    print(tile(9, 4))